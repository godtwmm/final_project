C51 COMPILER V7.08   FINAL                                                                 06/02/2025 23:35:06 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE FINAL
OBJECT MODULE PLACED IN final.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE final.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg52.h> //包含頭文件，一般情況不需要改動，頭文件包含特殊功能寄存器的定義                        
   2          #define DataPort P0 
   3          #define MAX 10
   4          unsigned char buf[MAX];
   5          unsigned char head = 0;
   6          //unsigned char recv_flag = 0;  // 接收完成標誌
   7          
   8          
   9          sbit LATCH1 = P2^2;  
  10          sbit LATCH2 = P2^3;  
  11          
  12          unsigned char code dofly_DuanMa[11]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x80};// 顯示段碼值
             -0~9
  13          unsigned char code dofly_WeiMa[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};//分別對應相應的數碼管點亮,即位
             -碼
  14          unsigned char TempData[8];
  15          /*------------------------------------------------
  16                             函數聲明
  17          ------------------------------------------------*/
  18          void SendStr(unsigned char *s);
  19          void SendByte(unsigned char dat);
  20          void delay_ms(unsigned int ms);
  21          void Display(unsigned char FirstBit, unsigned char Num);
  22          void ProcessReceivedData(void);
  23          /*------------------------------------------------
  24                              串口初始化
  25          ------------------------------------------------*/
  26          void InitUART  (void)
  27          {
  28   1      
  29   1          SCON  = 0x50;                       // SCON: 模式 1, 8-bit UART, 使能接收  
  30   1          TMOD |= 0x20;               // TMOD: timer 1, mode 2, 8-bit 重裝
  31   1          TH1   = 0xFD;               // TH1:  重裝值 9600 波特率 晶振 11.0592MHz  
  32   1          TR1   = 1;                  // TR1:  timer 1 打開                         
  33   1          EA    = 1;                  //打開總中斷
  34   1         // ES    = 1;                  //打開串口中斷
  35   1      }                            
  36          /*------------------------------------------------
  37                              主函數
  38          ------------------------------------------------*/
  39          void main (void)
  40          {
  41   1      
  42   1      InitUART();
  43   1      
  44   1      ES    = 1;                  //打開串口中斷
  45   1      while (1)                       
  46   1          {
  47   2                  if(head == 5) {
  48   3                          buf[head] = '\0'; 
  49   3                              head = 0;
  50   3                  ProcessReceivedData();
  51   3              }
  52   2              Display(0, 5);  // 顯示前5位數碼管    
  53   2          }
C51 COMPILER V7.08   FINAL                                                                 06/02/2025 23:35:06 PAGE 2   

  54   1      }
  55          
  56          /*------------------------------------------------
  57                              發送一個字節
  58          ------------------------------------------------*/
  59          void SendByte(unsigned char dat)
  60          {
  61   1       SBUF = dat;
  62   1       while(!TI);
  63   1            TI = 0;
  64   1      }
  65          /*------------------------------------------------
  66                              發送一個字符串
  67          ------------------------------------------------*/
  68          void SendStr(unsigned char *s)
  69          {
  70   1       while(*s!='\0')// \0 表示字符串結束標誌，通過檢測是否字符串末尾
  71   1        {
  72   2        SendByte(*s);
  73   2        s++;
  74   2        }
  75   1      }
  76          /*------------------------------------------------
  77                               串口中斷程序
  78          ------------------------------------------------*/
  79          void UART_SER (void) interrupt 4 //串行中斷服務程序
  80          {
  81   1          unsigned char Temp;          //定義臨時變量 
  82   1         
  83   1         if(RI)                        //判斷是接收中斷產生
  84   1           {
  85   2                      RI=0;                      //標誌位清零
  86   2                      Temp=SBUF;                 //讀入緩衝區的值
  87   2              //  P1=Temp;                   //把值輸出到P1口，用於觀察
  88   2          //  SBUF=Temp;                 //把接收到的值再發回電腦端
  89   2                      buf[head] = Temp;
  90   2                      head++;
  91   2                      if (head == MAX) head = 0;
  92   2               }
  93   1      //   if(TI)                        //如果是發送標誌位，清零
  94   1      //     TI=0;
  95   1      }
  96          
  97          void delay_ms(unsigned int ms)
  98          {
  99   1          unsigned int i, j;
 100   1          for(i = 0; i < ms; i++)
 101   1          {
 102   2              for(j = 0; j < 120; j++)
 103   2              {
 104   3                  ;  // 空循環，用來耗時
 105   3              }
 106   2          }
 107   1      }
 108          
 109          void Display(unsigned char FirstBit, unsigned char Num)
 110          {
 111   1          unsigned char i;
 112   1      
 113   1          for(i = 0; i < Num; i++)
 114   1          { 
 115   2              DataPort = 0;   
C51 COMPILER V7.08   FINAL                                                                 06/02/2025 23:35:06 PAGE 3   

 116   2              LATCH1 = 1;     
 117   2              LATCH1 = 0;
 118   2      
 119   2              DataPort = dofly_WeiMa[i + FirstBit];  
 120   2              LATCH2 = 1;     
 121   2              LATCH2 = 0;
 122   2      
 123   2              DataPort = TempData[i];  
 124   2              LATCH1 = 1;     
 125   2              LATCH1 = 0;
 126   2             
 127   2              delay_ms(200);     
 128   2          }
 129   1      }
 130          
 131          void ProcessReceivedData(void)
 132          {
 133   1          // 直接拆分前5個字符
 134   1          char ten = buf[0];      // 十位數字
 135   1          char unit = buf[1];     // 個位數字
 136   1          char dot = buf[2];      // 小數點
 137   1          char tenth = buf[3];    // 十分位
 138   1          char hundredth = buf[4];// 百分位
 139   1          
 140   1          // 十位數字
 141   1          if(ten >= '0' && ten <= '9') {
 142   2              TempData[0] = dofly_DuanMa[ten - '0'];
 143   2          } else {
 144   2              TempData[0] = 0x00; // 空白
 145   2          }
 146   1          
 147   1          // 個位數字
 148   1          if(unit >= '0' && unit <= '9') {
 149   2              TempData[1] = dofly_DuanMa[unit - '0'];
 150   2          } else {
 151   2              TempData[1] = 0x00; // 空白
 152   2          }
 153   1          
 154   1          // 小數點
 155   1          if(dot == '.') {
 156   2              TempData[2] = dofly_DuanMa[10]; // 小數點段碼
 157   2          } else {
 158   2              TempData[2] = 0x00; // 空白
 159   2          }
 160   1          
 161   1          // 十分位
 162   1          if(tenth >= '0' && tenth <= '9') {
 163   2              TempData[3] = dofly_DuanMa[tenth - '0'];
 164   2          } else {
 165   2              TempData[3] = 0x00; // 空白
 166   2          }
 167   1          
 168   1          // 百分位
 169   1          if(hundredth >= '0' && hundredth <= '9') {
 170   2              TempData[4] = dofly_DuanMa[hundredth - '0'];
 171   2          } else {
 172   2              TempData[4] = 0x00; // 空白
 173   2          }
 174   1      
 175   1      }


C51 COMPILER V7.08   FINAL                                                                 06/02/2025 23:35:06 PAGE 4   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    396    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
